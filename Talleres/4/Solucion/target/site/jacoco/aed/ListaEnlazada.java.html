<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ListaEnlazada.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">labo4</a> &gt; <a href="index.source.html" class="el_package">aed</a> &gt; <span class="el_source">ListaEnlazada.java</span></div><h1>ListaEnlazada.java</h1><pre class="source lang-java linenums">package aed;

import java.util.*;

public class ListaEnlazada&lt;T&gt; implements Secuencia&lt;T&gt; {
    private Nodo actual;
    private int len;

    private class Nodo {
        Nodo anterior;
        T elem;
        Nodo siguiente;

<span class="fc" id="L14">        public Nodo(T e) {  </span>
<span class="fc" id="L15">            elem = e;  </span>
<span class="fc" id="L16">        }</span>
    }

<span class="fc" id="L19">    public ListaEnlazada() {</span>
<span class="fc" id="L20">       actual = null;</span>
<span class="fc" id="L21">    }</span>

    public int longitud() {
<span class="fc" id="L24">        return len;</span>
    }

    public void agregarAdelante(T elem) {
<span class="fc" id="L28">        Nodo nuevoNodo = new Nodo(elem);</span>

<span class="fc" id="L30">        nuevoNodo.siguiente = actual;</span>
<span class="fc" id="L31">        actual = nuevoNodo;</span>

<span class="fc" id="L33">        len++;</span>
<span class="fc" id="L34">    }</span>

    public void agregarAtras(T elem) {
        //actual = (1,3,null)
<span class="fc" id="L38">        Nodo nuevoNodo = new Nodo(elem);</span>
        //nuevoNodo = (null, 2, null)
<span class="fc bfc" id="L40" title="All 2 branches covered.">        if (actual == null) {</span>
<span class="fc" id="L41">            actual = nuevoNodo;</span>
<span class="fc" id="L42">        } else {</span>
            //actual = (1,3,null)
            //nuevoNodo = (null, 2, null)
<span class="fc" id="L45">            Nodo cache = actual;</span>
            //cache = (1,3,null) = actual
            //nuevoNodo = (null, 2, null)

<span class="fc bfc" id="L49" title="All 2 branches covered.">            while (cache.siguiente != null) {</span>
<span class="fc" id="L50">                cache = cache.siguiente;</span>
            }

<span class="fc" id="L53">            cache.siguiente = nuevoNodo;</span>
            //cache = (1,3,2) = actual
            //nuevoNodo = (null, 2, null)
<span class="fc" id="L56">            nuevoNodo.anterior = cache;</span>
            //cache = (1,3,2)
            //nuevoNodo = (3, 2, null)
        }

<span class="fc" id="L61">        len++;</span>
<span class="fc" id="L62">    }</span>

    public T obtener(int i) {
<span class="fc" id="L65">        Nodo cache = actual;</span>
        // Pre ≡ 0 ≤ i &lt; len
        // 0 ≤ j &lt; i ∧ cache = cache.siguiente
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L69">            cache = cache.siguiente;</span>
        }

<span class="fc" id="L72">        return cache.elem;</span>
    }

    public void eliminar(int i) {
<span class="fc" id="L76">        Nodo cache = actual;</span>
<span class="fc" id="L77">        Nodo ant = null;</span>

        //Dado j &lt; i ent. separo en casos
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (i == 0) {</span>
<span class="fc" id="L81">            actual = cache.siguiente;</span>
<span class="fc" id="L82">        } else {</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L84">                ant = cache;</span>
<span class="fc" id="L85">                cache = cache.siguiente;</span>
            }

<span class="fc" id="L88">            ant.siguiente = cache.siguiente;</span>
        }

<span class="fc" id="L91">        len--;</span>
<span class="fc" id="L92">    }</span>

    public void modificarPosicion(int indice, T elem) {
<span class="fc" id="L95">        Nodo nuevo = new Nodo(elem);</span>
<span class="fc" id="L96">        Nodo cache = actual;</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">        for (int j = 0; j &lt; indice; j++) {</span>
<span class="fc" id="L99">            cache = cache.siguiente;</span>
        }

        //!!! ver por qué el contrarrecíproco no funciona.
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (cache.anterior == null) {</span>
<span class="fc" id="L104">            actual = nuevo;</span>
<span class="fc" id="L105">        } else {</span>
<span class="fc" id="L106">            (cache.anterior).siguiente = nuevo;</span>
        }
        
<span class="fc" id="L109">        nuevo.anterior = cache;</span>
        //nuevo: (cache,nuevo,siguiente)
        //cache: (ant,cache,siguiente)
<span class="fc" id="L112">        nuevo.siguiente = cache.siguiente;</span>
        //nuevo: (cache, nuevo, siguiente)
        //cache: (ant, cache, nuevo)
<span class="fc" id="L115">        cache.siguiente = nuevo;</span>
        
<span class="fc" id="L117">    }</span>

    public ListaEnlazada&lt;T&gt; copiar() {
<span class="fc" id="L120">        ListaEnlazada&lt;T&gt; copia = new ListaEnlazada&lt;&gt;(null);</span>
<span class="fc" id="L121">        Nodo cache = actual;</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">        while (cache != null) {</span>
<span class="fc" id="L124">            copia.agregarAtras(cache.elem);</span>
<span class="fc" id="L125">            cache = cache.siguiente;</span>
        }

<span class="fc" id="L128">        return copia;</span>
    }

<span class="fc" id="L131">    public ListaEnlazada(ListaEnlazada&lt;T&gt; lista) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (lista != null) {</span>
<span class="fc" id="L133">            ListaEnlazada&lt;T&gt; cache = lista.copiar();</span>
<span class="fc" id="L134">            actual = cache.actual;</span>
<span class="fc" id="L135">            len = cache.len;</span>
<span class="fc" id="L136">        } else {</span>
<span class="fc" id="L137">            actual = null;</span>
<span class="fc" id="L138">            len = 0;</span>
        }
 
<span class="fc" id="L141">    }</span>
    
    @Override
    public String toString() {
        
<span class="fc" id="L146">        Nodo cache = actual;</span>
<span class="fc" id="L147">        StringBuffer aString = new StringBuffer();</span>

<span class="fc" id="L149">        aString.append(&quot;[&quot;);</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        while (cache.siguiente != null) {</span>
<span class="fc" id="L152">            aString.append(cache.elem);</span>
<span class="fc" id="L153">            aString.append(&quot;, &quot;);</span>
<span class="fc" id="L154">            cache = cache.siguiente;</span>
        }
        //ver como implementarlo dentro del while
<span class="fc" id="L157">        aString.append(cache.elem);</span>
<span class="fc" id="L158">        aString.append(&quot;]&quot;);</span>

<span class="fc" id="L160">        return aString.toString();</span>
    }

    private class ListaIterador implements Iterador&lt;T&gt; {
        //i = iterador
<span class="fc" id="L165">    	int i = 0;</span>

<span class="fc" id="L167">        ListaIterador(){</span>
<span class="fc" id="L168">            i = 0;</span>
<span class="fc" id="L169">        }</span>

        public boolean haySiguiente() {
<span class="fc bfc" id="L172" title="All 2 branches covered.">	        return i != len;</span>
        }
        
        public boolean hayAnterior() {
<span class="fc bfc" id="L176" title="All 2 branches covered.">	        return i != 0;</span>
        }

        public T siguiente() {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (haySiguiente()) {</span>
<span class="fc" id="L181">                return obtener(i++);</span>
<span class="nc" id="L182">            } else {return null;}</span>
        }
        

        public T anterior() {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">            if (hayAnterior()) {</span>
                //decr --&gt;L eval
<span class="fc" id="L189">                return obtener(--i);</span>
<span class="nc" id="L190">            } else {return null;}</span>
        }
    }

    public Iterador&lt;T&gt; iterador() {
<span class="fc" id="L195">	    return new ListaIterador();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>